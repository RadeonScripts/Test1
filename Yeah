local Core = game:GetService("CoreGui")



Core.ChildAdded:Connect(function(name)

    wait()

    local o = name.Name

    if name.Name == "a" then

        return

    else

        name.Name = "a"

        name.Parent = game.Workspace

        local ScreenGui = Instance.new("ScreenGui")

        local Frame = Instance.new("Frame")

        ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

        ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

        Frame.Parent = ScreenGui

        Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

        Frame.Position = UDim2.new(-100000, -100000, -100000, 0)

        Frame.Size = UDim2.new(0, 100, 0, 100)

        name.Parent = ScreenGui

        wait(1)

        name.Name = o

        game.Players.LocalPlayer.CharacterRemoving:Connect(function()

            ScreenGui.Parent = game.Workspace

        end)

        game.Players.LocalPlayer.CharacterAdded:Connect(function()

           ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

        end)

    end

end)
getgenv().rj = true
local mt = getrawmetatable(game);
    make_writeable(mt);
    local old_index = mt.__index;
    
    mt.__index = function(a, b)
    if tostring(a) == "HumanoidRootPart" then
    if tostring(b) == "Size" then
    return Vector3.new(2, 2, 1);
    end
    end
    return old_index(a, b);
    end



spawn(function()
game:GetService('RunService').RenderStepped:connect(function()

for i,v in pairs(game:GetService('Players'):GetPlayers()) do

    if v.Name ~= game.Players.LocalPlayer.Name then

game.Workspace[v.Name].HumanoidRootPart.Size = SizeXCV

game.Workspace[v.Name].HumanoidRootPart.Transparency = TransparencyXCV or SizeXCVs

game.Workspace[v.Name].HumanoidRootPart.Color = ColourXCV

game.Workspace[v.Name].HumanoidRootPart.Material = "ForceField"

game.Workspace[v.Name].HumanoidRootPart.CanCollide = false

wait()

end

end

end)

end)

local Http = game:GetService("HttpService")
local TPS = game:GetService("TeleportService")
local Api = "https://games.roblox.com/v1/games/"
local _place = game.PlaceId
local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"


local players = game:GetService("Players")

function getPlayers()
  return #players:GetPlayers()
end

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

local Player = game:GetService("Players").LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera
local Mouse = game:GetService("Players").LocalPlayer:GetMouse()

FOV_Circle = Drawing.new("Circle")
FOV_Circle.Color = Color3.fromRGB(255,255,255)
FOV_Circle.Thickness = 1
FOV_Circle.NumSides = 300
FOV_Circle.Radius = 250
FOV_Circle.Visible = false
FOV_Circle.Filled = false

local function ClosestPlayerToCursor()
    local Closest = nil
    local Distance = 9e9
    for i, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v ~= Player then
            if Workspace[v.Name]:FindFirstChild("Humanoid") and Workspace[v.Name].Humanoid.Health ~= 0 then
                local Position = Camera:WorldToViewportPoint(Workspace[v.Name].HumanoidRootPart.Position)
                local Magnitude = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if Magnitude < Distance and Magnitude < FOV_Circle.Radius then
                    Closest = Workspace[v.Name]
                    Distance = Magnitude
                end
            end
        end
    end
    return Closest
end

local ScriptConnections = {}

local game=game;
local workspace=workspace;

local FFC = game.FindFirstChild;
local FFCWhichIsA = game.FindFirstChildWhichIsA;
local FindPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList;

local Players = game:GetService("Players");
local GetPlayers = Players.GetPlayers;
local LocalPlayer = Players.LocalPlayer;

local UIS = game:GetService("UserInputService");
local GML = UIS.GetMouseLocation;

local Camera = workspace.CurrentCamera;
local WorldToViewportPoint = Camera.WorldToViewportPoint;

local Vector2New = Vector2.new;
local function SpaceToVector2(Space)
    local Pos, IsVisible = WorldToViewportPoint(Camera, Space);

    return Vector2New(Pos.X, Pos.Y), IsVisible, Pos.Z;
end;

local ClosestPlayerToMouse;
local ClosestPlayerToMouseDistance;

local function GetCharacter(Player)
    return FFC(workspace, Player.Name);
end;

local Players = game:GetService("Players");
local LocalPlayer = Players.LocalPlayer;
local Backpack = LocalPlayer.Backpack;
local LocalCharacter = LocalPlayer.Character;
local LocalRootPart = Instance;
local LocalHumanoid = Instance;

local UI = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui"):WaitForChild("UI");
local TargetFrame = UI.Target;
local TargetVisible = TargetFrame.Visible;
local TargetText = TargetFrame.TargetText;
local Target = TargetVisible and Players:FindFirstChild(TargetText.Text);
game:GetService('RunService').Stepped:connect(function()
    FOV_Circle.Position = Vector2.new(Mouse.X, Mouse.Y + 37)
end)
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Rayfield/main/source'))()
local ESP = loadstring(game:HttpGet("https://kiriot22.com/releases/ESP.lua"))()
local Window = Rayfield:CreateWindow({
   Name = "Radeon.OP Free",
   LoadingTitle = "Radeon.OP Free",
   LoadingSubtitle = "By Radeon",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = "Radeon.OP Free Test1", -- Create a custom folder for your hub/game
      FileName = "Radeon.OP Free Configss"
   },
   Discord = {
      Enabled = true,
      Invite = "mekHv9Wp", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD.
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Radeon Key System!",
      Subtitle = "Key should be 9 digits, Rejoin once entered!",
      Note = "Enter your key from link vertise here!",
      FileName = "RadeonKey",
      SaveKey = true,
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = "123456789"
   }
})


local Combat = Window:CreateTab("Combat") -- Title, Image

local AF = Window:CreateTab("Autofarm") -- Title, Image

local LP = Window:CreateTab("Player") -- Title, Image

local HBE = Window:CreateTab("HBE/ESP") -- Title, Image

local AB = Window:CreateTab("Auto Buy") -- Title, Image

local Other = Window:CreateTab("Other") -- Title, Image

local hi = Window:CreateTab("UI Settings") -- Title, Image










--- COMBAT TAB 


local Section = Combat:CreateSection("Silent Aim")

_G.Toggle = false
local Button = Combat:CreateButton({
    Name = "OP Silent Aim (FOV) Press F",
    Callback  = function()
                            game.StarterGui:SetCore("SendNotification", {

                        Title = "Silent Aim";

                        Text = "Press F to enable/disable silent aim. ONLY CLICK THE BUTTON ONCE!";

                        Duration = 10;

                    })
            local Player = game:GetService("Players").LocalPlayer

    local Camera = game:GetService("Workspace").CurrentCamera

    local Mouse = game:GetService("Players").LocalPlayer:GetMouse()



    FOV_Circle = Drawing.new("Circle")

    FOV_Circle.Color = Color3.fromRGB(255,255,255)

    FOV_Circle.Thickness = 2.5

    FOV_Circle.NumSides = 300

    FOV_Circle.Radius = 200

    FOV_Circle.Visible = false

    FOV_Circle.Filled = false



    game:GetService('RunService').Stepped:connect(function()

        FOV_Circle.Position = Vector2.new(Mouse.X, Mouse.Y + 37)

    end)



    local function ClosestPlayerToCursor()

        local Closest = nil

        local Distance = 9e9

        for i, v in pairs(game:GetService("Players"):GetPlayers()) do

            if v ~= Player then

                if Workspace[v.Name]:FindFirstChild("Humanoid") and Workspace[v.Name].Humanoid.Health ~= 0 then

                    local Position = Camera:WorldToViewportPoint(Workspace[v.Name].HumanoidRootPart.Position)

                    local Magnitude = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude

                    if Magnitude < Distance and Magnitude < FOV_Circle.Radius then

                        Closest = Workspace[v.Name]

                        Distance = Magnitude

                    end

                end

            end

        end

        return Closest

    end



    _G.Toggle = false

    spawn(function()

        game:GetService('RunService').RenderStepped:connect(function()

            pcall(function()

                if _G.Toggle then

                    for i, v in pairs(game:GetService("Workspace").KnifeHost.PowerUps:GetDescendants()) do

                        if v:IsA("Part") then

                            v.Archivable = false

                        end

                    end

                end

            end)

        end)

    end)





    spawn(function()

        game:GetService('RunService').RenderStepped:connect(function()

            pcall(function()

                if _G.Toggle then

                    for i, v in pairs(game:GetService("Workspace").KnifeHost:GetDescendants()) do

                        if v:IsA("Part") then

                            if v.Archivable == true then

                                local PlayerPosition = ClosestPlayerToCursor().baseHitbox.CFrame

                                v.CFrame = PlayerPosition

                            end

                        end

                    end

                end

            end)

        end)

    end)

    spawn(function()

        pcall(function()

            Mouse.KeyDown:Connect(function(key)

                if key == "f" and _G.Toggle == false then

                    _G.Toggle = true

                    FOV_Circle.Visible = true

                    

                elseif key == "f" and _G.Toggle == true then

                    _G.Toggle = false

                    FOV_Circle.Visible = false



                end

            end)

        end)

    end)



        
        
        
   
end})
	


local colorPicker = Combat:CreateColorPicker({
    Name = "FOV Color",
    Color = Color3.fromRGB(100, 0, 255),
    Flag = "Color picker 1",
    Callback = function(t)
        FOV_Circle.Color = t
end
})


local Slider = Combat:CreateSlider({
   Name = "FOV Size",
   Range = {15, 300},
   Increment = 1,
   Suffix = "",
   CurrentValue = 150,
   Flag = "Slider 1", 
   Callback = function(t)
FOV_Circle.Radius = t
   end,
})


local Section = Combat:CreateSection("Knife")
getgenv().StabAuraToggle = false
local Toggle = Combat:CreateToggle({
   Name = "Stab Aura",
   CurrentValue = false,
   Flag = "Filled FOV", 
   Callback = function(bool)
       getgenv().StabAuraToggle = bool
   end,
})

do
    local function characterAdded(Character)
        if typeof(Character) ~= "Instance" then return;end;
        LocalCharacter = Character;
        LocalRootPart = Character:WaitForChild("HumanoidRootPart");
        LocalHumanoid = Character:WaitForChild("Humanoid");
    end;
    characterAdded(LocalCharacter);
    LocalPlayer.CharacterAdded:Connect(characterAdded);
end

local Player = game.Players.LocalPlayer
local wS = game.Workspace
local ClosestPlayer = function()
    local Closest = nil
    local Distance = 9e9
    for i, v in next, game:GetService("Players"):GetPlayers() do
        if v.Name ~= Player.Name then
            if wS[v.Name] and wS[v.Name]:FindFirstChild("Humanoid") and wS[v.Name]:FindFirstChild("Humanoid").Health ~= 0 then
                local Magnitude = (Player.Character.Head.Position - wS[v.Name].Head.Position).Magnitude
                if Magnitude < Distance then
                    Closest = wS[v.Name]
                    Distance = Magnitude
                    end
                end
            end
        end
    return Closest
end
local cooldown = false

task.spawn(function()
    game:GetService("RunService").Stepped:connect(function()
        if getgenv().StabAuraToggle == true and Player.Character and not cooldown then
            if Player:DistanceFromCharacter(ClosestPlayer().Torso.Position) <= 6.5 then
                Player.PlayerScripts.localknifehandler.HitCheck:Fire(ClosestPlayer())
                coroutine.wrap(function()
                    cooldown = true
                    task.wait(0.8)
                    cooldown = false
                end)()
            else
                task.wait()
            end
        end
    end)
end)
local Section = AF:CreateSection("Autofarm")
getgenv().Autofarm = false;
local Toggle = AF:CreateToggle({
   Name = "Free TP Autofarm!",
   CurrentValue = false,
   Flag = "TP Autofarm", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(n)
       getgenv().Autofarm = n
   end,
})

if shared.n2autofarm then shared.n2autofarm:Disconnect();end;
local Players = game:GetService("Players");
local LocalPlayer = Players.LocalPlayer;
local Backpack = LocalPlayer.Backpack;
local LocalCharacter = LocalPlayer.Character;
local LocalRootPart;
local LocalHumanoid;

--local character
do
    local function characterAdded(Character)
        if typeof(Character) ~= "Instance" then return;end;
        LocalCharacter = Character;
        LocalRootPart = Character:WaitForChild("HumanoidRootPart");
        LocalHumanoid = Character:WaitForChild("Humanoid");
    end;
    characterAdded(LocalCharacter);
    LocalPlayer.CharacterAdded:Connect(characterAdded);
end;

local UI = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui"):WaitForChild("UI");
local TargetFrame = UI.Target;
local TargetVisible = TargetFrame.Visible;
local TargetText = TargetFrame.TargetText;
local Target = TargetVisible and Players:FindFirstChild(TargetText.Text);
local TargetCharacter;
local TargetRootPart;

TargetFrame.Changed:Connect(function()
    TargetVisible = TargetFrame.Visible;
end);
TargetText.Changed:Connect(function()
    Target = Players:FindFirstChild(TargetText.Text);
end);

local VotePad = workspace.Lobby.VoteStation.pad3.Position;
local function getClosestPlayer()
    local Closest;
    local MaxDistance;

    for I, Player in next, Players:GetPlayers() do
        if Player ~= LocalPlayer and LocalRootPart then
            local Character = workspace:FindFirstChild(Player.Name);
            local RootPart = Character and Character:FindFirstChild("HumanoidRootPart");
            local Humanoid = RootPart and Character:FindFirstChild("Humanoid");

            if Humanoid and Humanoid.Health > 0 then
                local Distance = (VotePad - RootPart.Position).Magnitude;
                if Distance > 300 then
                    Distance = (LocalRootPart.Position - RootPart.Position).Magnitude;
                    if Closest then
                        if Distance < MaxDistance then
                            Closest = Player;
                            MaxDistance = Distance;
                        end;
                    else
                        Closest = Player;
                        MaxDistance = Distance;
                    end;
                end;
            end;
        end;
    end;

    return Closest, MaxDistance;
end;
local ClosestPlayer;
local ClosestPlayerCharacter;
local ClosestPlayerRootPart;

local HitCheckCooldown = false;
local HitCheck = LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("localknifehandler"):WaitForChild("HitCheck");
local ThrowKnife = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("ThrowKnife");

local ThrowCooldown = false;
local ThrowCFrame = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1);

local TPTweenInfo = TweenInfo.new(0, Enum.EasingStyle.Linear, Enum.EasingDirection.Out);
local TPOffset = CFrame.new(-2, -3.96, 1.6);

local TweenService = game:GetService("TweenService");
shared.n2autofarm = game:GetService("RunService").Heartbeat:Connect(function()
    ClosestPlayer = getClosestPlayer();
    ClosestPlayerCharacter = ClosestPlayer and workspace:FindFirstChild(ClosestPlayer.Name);
    ClosestPlayerRootPart = ClosestPlayerCharacter and ClosestPlayerCharacter:FindFirstChild("HumanoidRootPart");
    
    -- print(TargetVisible, Target, LocalCharacter, LocalRootPart, LocalHumanoid);
    if TargetVisible and Target and LocalCharacter and LocalRootPart and LocalHumanoid and getgenv().Autofarm == true then
        TargetCharacter = workspace:FindFirstChild(Target.Name);
        TargetRootPart = TargetCharacter and TargetCharacter:FindFirstChild("HumanoidRootPart");

    --Teleport
        workspace.Gravity = -2;
        LocalHumanoid:SetStateEnabled(15, false);
        TweenService:Create(
            LocalRootPart,
            TPTweenInfo,
            {CFrame = TargetRootPart.CFrame * TPOffset}
        ):Play();
    end;
end);

local Player = game.Players.LocalPlayer;

local cooldown = false

task.spawn(function()
    game:GetService("RunService").Stepped:connect(function()
        if Player.Character and not cooldown and game.Players.LocalPlayer.PlayerGui.ScreenGui.UI.Target.Visible == true and getgenv().Autofarm == true then
            if Player:DistanceFromCharacter(game.Workspace[game.Players.LocalPlayer.PlayerGui.ScreenGui.UI.Target.TargetText.Text].Head.Position) <= 6.5 then
                Player.PlayerScripts.localknifehandler.HitCheck:Fire(game.Workspace[game.Players.LocalPlayer.PlayerGui.ScreenGui.UI.Target.TargetText.Text])
                coroutine.wrap(function()
                    cooldown = true
                    task.wait(0.8)
                    cooldown = false
                end)()
            else
                task.wait()
            end
        end
    end)
end)



task.spawn(function()
    game:GetService("RunService").Stepped:connect(function()
        if getgenv().Autofarm == false then
            workspace.Gravity = 192.6
      end      
end)
end)



local Section = AF:CreateSection("Autofarm Settings")
local Toggle = AF:CreateToggle({
   Name = "Auto Server Hop (4 Players)",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(s)
       getgenv().ServerHop = s
   end,
})



getgenv().RL = false
local Toggle = AF:CreateToggle({
   Name = "Remove Limbs",
   CurrentValue = false,
   Flag = "Toggle5", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(r)
       getgenv().RL = r
   end,
})
task.spawn(function()
    game:GetService("RunService").Stepped:connect(function()
        if getgenv().RL == true then
            game.Players.LocalPlayer.Character['Right Leg']:remove()
game.Players.LocalPlayer.Character['Left Leg']:remove()
      end      
end)
end)
getgenv().DM = false
local Toggle = AF:CreateToggle({
   Name = "Destroy Map",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(m)
       getgenv().DM = m
   end,
   
})

task.spawn(function()
    game:GetService("RunService").Stepped:connect(function()
        if getgenv().DM == true then
            game.Workspace.GameMap:Destroy()
        end 
  end)
end)
getgenv().Advertise = false
local Toggle = AF:CreateToggle({
   Name = "Advertise",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(ad)
                   
                   if ad then
                       game.StarterGui:SetCore("SendNotification", {

        Title = "Advertise";

        Text = "Thank you for using advertise!!! Please note that only the other players can see it (You can't)";

        Duration = 10;


})
end
       getgenv().Advertise = ad
   end,
})



getgenv().GhostFarmToggle = false
local Section = AF:CreateSection("Auto Collect")
local Toggle = AF:CreateToggle({
   Name = "GhostCoin Farm",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(bool)
       getgenv().GhostFarmToggle = bool

   end,
})


game.Players.LocalPlayer.CharacterAdded:connect(function()
    if getgenv().GhostFarmToggle == true then
        game.ReplicatedStorage.Remotes.RequestGhostSpawn:InvokeServer()
    
        task.spawn(function()
            game.RunService.Stepped:connect(function()
                for i,v in pairs(game.Workspace.GhostCoins:GetDescendants()) do
                    if v:IsA"TouchTransmitter" then
                        firetouchinterest(game.Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 0) 
                        task.wait()
                        firetouchinterest(game.Players.LocalPlayer.Character.HumanoidRootPart, v.Parent, 1)
                    end
                end
            end)
        end)
    end
end)
getgenv().AutoCandy = false
local Toggle = AF:CreateToggle({
   Name = "Auto Candy Collect",
   CurrentValue = false,
   Flag = "Toggle 1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(a)
       getgenv().AutoCandy = a
   end,
})



--- LOCAL PLAYER


local Section = LP:CreateSection("Local Player")
_G.WalkSpeed = false
local Toggle = LP:CreateToggle({
   Name = "Custom WalkSpeed",
   CurrentValue = false,
   Flag = "Toggle 1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(bool)
       _G.WalkSpeed = bool

   end,
})

local WalkSpeedValue = 16

local Slider = LP:CreateSlider({
   Name = "Speed",
   Range = {1, 35},
   Increment = 1,
   Suffix = "",
   CurrentValue = 16,
   Flag = "Slider 1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(value)
       WalkSpeedValue = value
   end,
})

task.spawn(function()
    game.RunService.Stepped:connect(function()
        if _G.WalkSpeed == true then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = WalkSpeedValue
        else
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
        end
    end)
end)


_G.JumpPower = false
local Toggle = LP:CreateToggle({
    Name = "Custom JumpPower",
    CurrentValue = false,
    Flag = "Toggle 1",
    Callback  = function(bool)
        _G.JumpPower = bool
    end
})
local JumpPowerValue = 16

local Slider = LP:CreateSlider({
    Name = "JumpPower Height",
    Range = {1, 200},
    Increment = 1,
    Suffix = "",
    CurrentValue = 50,
    Flag = "Slider 1",
    Callback = function(value)
        JumpPowerValue = value
    end
})
task.spawn(function()
    game.RunService.Stepped:connect(function()
        if _G.JumpPower == true then
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = JumpPowerValue
        else
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50
        end
    end)
end)

_G.HipHeight = false
local Toggle = LP:CreateToggle({
   Name = "Custom HipHeight",
   CurrentValue = false,
   Flag = "Toggle 1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(bool)
       _G.HipHeight = bool
   end,
})

local HipHeightValue = 0
local Slider = LP:CreateSlider({
   Name = "HipHeight",
   Range = {0, 20},
   Increment = 1,
   Suffix = "",
   CurrentValue = 10,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(value)
       HipHeightValue = value
   end,
})

task.spawn(function()
    game.RunService.Stepped:connect(function()
        if _G.HipHeight == true then
            game.Players.LocalPlayer.Character.Humanoid.HipHeight = HipHeightValue
        else
            game.Players.LocalPlayer.Character.Humanoid.HipHeight = 0
        end
    end)
end)







local Section = HBE:CreateSection("HBE")
local Button = HBE:CreateButton({
   Name = "OP Hitbox Expander!",
   Callback = function()
                               getfenv().hbe = true

    if getfenv().hbe == true then

    local mt = getrawmetatable(game);

    make_writeable(mt);

    local old_index = mt.__index;



    mt.__index = function(a, b)

    if tostring(a) == "HumanoidRootPart" then

    if tostring(b) == "Size" then

    return Vector3.new(2, 2, 1);

    end

    end

    return old_index(a, b);

    end





    if shared.ShushHighlight then shared.ShushHighlight.stop();end;



    local Connection = {};

    Connection.__index = Connection;

    Connection.__tostring = function(self)

        return self.Name;

    end;



    Connection.new = function(Event, Func, Once)

        return setmetatable({Name = Event.Name .. ".Connection", Event = Event, Func = Func, Once = Once}, Connection);

    end;



    Connection.Disconnect = function(self)

        table.remove(self.Event._connections, table.find(self.Event._connections, self));

    end;





    local Event = {};

    Event.__index = Event;

    Event.__tostring = function(self)

        return self.Name;

    end;



    Event.new = function(Name)

        return setmetatable({Name = Name or "Event", _connections={}, _waits={}}, Event);

    end;



    Event.Connect = function(self, Func)

        local connection = Connection.new(self, Func);

        table.insert(self._connections, connection);

        return connection;

    end;

    Event.Fire = function(self, ...)

        local Args = {...};

        task.spawn(function()

            for I, Con in next, self._connections do

                Con.Func(unpack(Args));

            end;

        end);

    end;





    local Target;



    local PlayerService = game:GetService("Players");

    local LP = PlayerService.LocalPlayer;



    local FFC = game.FindFirstChild;



    local TargetObject = LP:WaitForChild("PlayerGui").ScreenGui.UI.Target;

    local TargetText = TargetObject.TargetText;



    do

        local T = TargetText.Text;

        local V = TargetText.Visible;

        local V2 = TargetObject.Visible;



        if V and V2 then

            if T and #T > 1 then

                Target = FFC(PlayerService, T);

            end;

        end;

    end;



    local INSTChanged = Event.new("InstChanged");

    local TARGETChanged = Event.new("TargetChanged");

    local HITBOXChanged = Event.new("HitboxChanged");

    local TARGETHITBOXChanged = Event.new("TargetHitboxChanged");



    local SettingsProxy = {Target = true};



    local INSTProxy = {

        FillColor = Color3.new(0, 1, 0),

        FillTransparency = 0.5,



        OutlineColor = Color3.new(1, 1, 1),

        OutlineTransparency = 0;

    };

    local TARGETProxy = {

        FillColor = Color3.new(1, 0, 0),

        FillTransparency = 0.5,



        OutlineColor = Color3.new(1, 1, 1),

        OutlineTransparency = 0;

    };

    local HITBOXProxy = {

        Size = Vector3.new(2,2,1),

        Transparency = 1

    };

    local TARGETHITBOXProxy = {

        Size = Vector3.new(2,2,1),

        Transparency = 1

    };



    local Settings = setmetatable({}, {__index = SettingsProxy, __newindex = function(self, key, value)

        if key == "Target" then 

            for i,v in next, TARGETProxy do

                TARGETChanged:Fire(i,v);

            end;

        end;



        SettingsProxy[key] = value;

    end});

    Settings.INST = setmetatable({}, {__index = INSTProxy, __newindex = function(self, Key, Value)

        if INSTProxy[Key] then

            INSTChanged:Fire(Key, Value);

            INSTProxy[Key] = Value;



            return;

        end;



        return error(tostring(Key), " is not a valid key");

    end});

    Settings.TARGET = setmetatable({}, {__index = TARGETProxy, __newindex = function(self, Key, Value)

        if TARGETProxy[Key] then

            TARGETChanged:Fire(Key, Value);

            TARGETProxy[Key] = Value;



            return;

        end;



        return error(tostring(Key), " is not a valid key");

    end});

    Settings.HITBOX = setmetatable({}, {__index = HITBOXProxy, __newindex = function(self, Key, Value)

        if HITBOXProxy[Key] then

            HITBOXChanged:Fire(Key, Value);

            HITBOXProxy[Key] = Value;



            return;

        end;



        return error(tostring(Key), " is not a valid key");

    end});

    Settings.TARGETHITBOX = setmetatable({}, {__index = TARGETHITBOXProxy, __newindex = function(self, Key, Value)

        if TARGETHITBOXProxy[Key] then

            TARGETHITBOXChanged:Fire(Key, Value);

            TARGETHITBOXProxy[Key] = Value;



            return;

        end;



        return error(tostring(Key), " is not a valid key");

    end});



    local Highlight = {

        Active = true,

        Connections = {},

        Settings = Settings

    };

    Highlight.__index = Highlight;



    Highlight.new = function(Character, Player)

        local cache = {};



        local Inst = Instance.new("Highlight");

        Inst.Adornee = Character;

        Inst.Parent = Character;



        if Settings.Target and Target and Player == Target then

            for k,v in next, TARGETProxy do

                Inst[k] = v;

                cache[k] = v;

            end;

        else

            for k, v in next, INSTProxy do

                Inst[k] = v;

                cache[k] = v;

            end;

        end;



        local SettingsCon; SettingsCon = INSTChanged:Connect(function(k,v)

            if cache[k] == v then return;end;

            if Settings.Target and Target and Target and Player == Target then return;end;

            Inst[k] = v;

            -- cache[k] = v;

        end);

        local TargetCon; TargetCon = TARGETChanged:Connect(function(k,v)

            if cache[k] == v then return;end;

            if not (Settings.Target and Target and Player == Target) then return;end;

            Inst[k] = v;

            -- cache[k] = v;

        end);

        Inst.Changed:Connect(function(P)

            cache[P] = Inst[P];

        end);





        local highlight = setmetatable({

            Active = true,

            Inst = Inst,

            Character = Character,

            SettingsCon = SettingsCon,

            TargetCon = TargetCon;

        }, Highlight);



        return highlight;

    end;



    Highlight.Destroy = function(self)

        if not self.Active then return;end;

        self.Active = false;

        self.SettingsCon:Disconnect();

        self.TargetCon:Disconnect();

        self.Inst:Destroy();

    end;



    local Extender = {};

    Extender.__index = Extender;



    Extender.new = function(Character, Player)

        local HRP = Character:FindFirstChild("HumanoidRootPart");



        local HitboxCon = HITBOXChanged:Connect(function(k,v)

            if not HRP then return;end;

            if Settings.Target and Target and Target and Player == Target then return;end;

            HRP[k] = v;

        end);

        local TargetHitboxCon = TARGETHITBOXChanged:Connect(function(k,v)

            if not HRP then return;end;

            if not (Settings.Target and Target and Target and Player == Target) then return;end;

            HRP[k] = v;

        end);



        local extender = setmetatable({

            Active = true,

            HitboxCon = HitboxCon,

            TargetHitboxCon = TargetHitboxCon,

            HRP = HRP,

        }, Extender);



        task.spawn(function()

            if not HRP then repeat task.wait();HRP = Character:FindFirstChild("HumanoidRootPart");until HRP;end;

            extender.HRP = HRP;



            if Settings.Target and Target and Player == Target then

                for k,v in next, TARGETHITBOXProxy do

                    HRP[k] = v;

                end;

            else

                for k, v in next, HITBOXProxy do

                    HRP[k] = v;

                end;

            end;

        end);



        return extender;

    end;

    Extender.Destroy = function(self)

        if not self.Active then return;end;

        self.Active = false;

        self.HitboxCon:Disconnect();

        self.TargetHitboxCon:Disconnect();

    end;



    local function GetCharacter(Player)

        return workspace:FindFirstChild(Player.Name);

    end;



    local PlayerObject = {};

    PlayerObject.__index = PlayerObject;



    PlayerObject.new = function(Player)

        if typeof(Player) ~= "Instance" or Player == LP then return;end;

        local playerobject = setmetatable({

            Active = true,

            Player = Player,

            Character = GetCharacter(Player) or Player.CharacterAdded:Wait();

        }, PlayerObject);



        task.spawn(function()

            playerobject.Highlight = Highlight.new(playerobject.Character, Player);

        end);

        task.spawn(function()

            playerobject.Extender = Extender.new(playerobject.Character, Player);

        end);



        local con = Player.CharacterAdded:Connect(function(Character)

            task.spawn(function()

                if playerobject.Highlight then playerobject.Highlight:Destroy();end;

                playerobject.Highlight = Highlight.new(Character, Player);

            end);

            task.spawn(function()

                if playerobject.Extender then playerobject.Extender:Destroy();end;

                playerobject.Extender = Extender.new(Character, Player);

            end);

        end);

        playerobject.CharacterAddedCon = con;



        PlayerObject[Player] = playerobject;



        return playerobject;

    end;



    PlayerObject.Destroy = function(self)

        if not self.Active then return;end;



        self.Active = false;

        if self.Highlight then self.Highlight:Destroy();end;

        if self.Extender then self.Extender:Destroy();end;

        self.CharacterAddedCon:Disconnect();



    end;



    Highlight.HandlePlayers = function()

        for I, Player in next, PlayerService:GetPlayers() do

            PlayerObject.new(Player);

        end;



        table.insert(Highlight.Connections, PlayerService.PlayerAdded:Connect(PlayerObject.new));

        table.insert(Highlight.Connections, PlayerService.PlayerRemoving:Connect(function(Player)

            if PlayerObject[Player] then

                PlayerObject[Player]:Destroy();

            end;

        end));

    end;

    Highlight.stop = function()

        if not Highlight.Active then return;end;



        Highlight.Active = false;

        for I, V in next, PlayerObject do

            if typeof(I) == "Instance" then

                V:Destroy();

            end;

        end;



        for i,v in next, Highlight.Connections do

            v:Disconnect();

        end;

    end;



    local ReplicatedStorage = game:GetService("ReplicatedStorage");

    local Remotes = ReplicatedStorage.Remotes;

    local HideTarget = Remotes.HideTarget;

    local UpdateTarget = Remotes.UpdateTarget;



    table.insert(Highlight.Connections, HideTarget.OnClientEvent:Connect(function()

        Target = nil;



        for k,v in next, INSTProxy do

            INSTChanged:Fire(k,v);

        end;

    end));

    table.insert(Highlight.Connections, UpdateTarget.OnClientEvent:Connect(function(T)

        Target = T;



        local p = PlayerObject[Target]

        local h = p and p.Highlight;



        if h then

            for k,v in next, TARGETProxy do

                h.Inst[k] = v;

            end;

        end;



        local e = p and p.Extender;

        if e then

            for k,v in next, TARGETHITBOXProxy do

                e.HRP[k] = v;

            end;

        end;

    end));



    Highlight.HandlePlayers();

    shared.ShushHighlight = Highlight;

    local Settings = shared.ShushHighlight.Settings;



    Settings.HITBOX.Size = Vector3.new(15,15,15);

    Settings.HITBOX.Transparency = 0.5;

    Settings.TARGETHITBOX.Size = Vector3.new(25,25,25);

    Settings.TARGETHITBOX.Transparency = 0.5;



    Settings.INST.FillColor = Color3.fromRGB(0, 0, 0);

    Settings.TARGET.OutlineColor = Color3.fromRGB(0, 0, 0);

    elseif getfenv().hbe == false then

        print('disabled hbe')

   end
end})

local Section = HBE:CreateSection("ESP")
local Toggle = HBE:CreateToggle({
	Name = "ESP Boxes (May take a bit to load)",
	CurrentValue = false,
	Flag = "ESP",
	Callback = function(H)
		ESP:Toggle(H)
	end    
})


local Section = AB:CreateSection("Season Pass")
local Button = AB:CreateButton({
    Name = "Collect Season Pass",
    Callback  = function()
        local Claim_Pass = function(Claim)
    game:GetService("ReplicatedStorage").Remotes.CompRemotes.RequestTier:FireServer(Claim);
end

task.spawn(function()
    for i = 1, 10 do
        Claim_Pass(i);
    end
end)
    end
})
local Section = AB:CreateSection("Auto Buy (With Candy)")

local Button = AB:CreateButton({
    Name = "Auto Buy Key",
    Callback  = function()
_G.autoBuy = true;
while _G.autoBuy == true do
    game:GetService("ReplicatedStorage").Remotes.RequestCandyItemPurchase:InvokeServer(unpack({[1] = "Key"}))
    wait()
end
end})


local Button = AB:CreateButton({
    Name = "Auto Buy Cookie Cutter",
    Callback  = function()
_G.autoBuy = true;
while _G.autoBuy == true do
    game:GetService("ReplicatedStorage").Remotes.RequestCandyItemPurchase:InvokeServer(unpack({[1] = "Cookie Cutter"}))
    wait()
end
end})

local Button = AB:CreateButton({
    Name = "Auto Buy Blocky Blade",
    Callback  = function()
_G.autoBuy = true;
while _G.autoBuy == true do
    game:GetService("ReplicatedStorage").Remotes.RequestCandyItemPurchase:InvokeServer(unpack({[1] = "Blocky Blade"}))
    wait()
end
end})

local Button = AB:CreateButton({
    Name = "Auto Buy Event Mythic",
    Callback  = function()
_G.autoBuy = true;
while _G.autoBuy == true do
    game:GetService("ReplicatedStorage").Remotes.RequestCandyItemPurchase:InvokeServer(unpack({[1] = "Frigid Flambeau"}))
    wait()
end
end})
local Section = Other:CreateSection("Misc")


local Button = Other:CreateButton({
    Name = "Inventory Calculator",
    Callback  = function()
        loadstring(game:HttpGet"https://gitlab.com/te4224/Scripts/-/raw/main/misc-scripts/UniversalValueCalculator.lua")();
end})


local Button = Other:CreateButton({
    Name = "Trade Crash",
    Callback  = function()
        	    local t = {}

for i = 1, 50000 do
    t[i] = {
        [1] = "Key", -- replace example with a knife in your inventory
        [2] = 1
    }
end

game:GetService("ReplicatedStorage").Remotes.UpdateTradeOffer:FireServer(t)
  	end})

local Section = Other:CreateSection("Map")

local Button = Other:CreateButton({
    Name = "Remove Textures",
    Callback  = function()
        	    local hasProperty = function(a, b)
    local c = a[b];
end
    
task.spawn(function()
    for i, v in next, workspace:GetDescendants() do
        local Check = pcall(function()hasProperty(v, "Material")end)
        
        if Check then
            v.Material = "Plastic";
        end
    end
    
    workspace.DescendantAdded:Connect(function(v)
        local Check = pcall(function()hasProperty(v, "Material")end)
        
        if Check then
            v.Material = "Plastic";
        end
    end)
end)
  	end})


local Button = Other:CreateButton({
    Name = "Remove Map",
    Callback  = function()
        	    game.Workspace.GameMap:Destroy()
end})


local Button = Other:CreateButton({
    Name = "RTX Shaders",
    Callback  = function()
         loadstring(game:HttpGet("https://raw.githubusercontent.com/helloDelvuss/NIGGARTX/main/EZRTX",true))();
end})



local Section = Other:CreateSection("Teleports")
local Button = Other:CreateButton({
    Name = "Rejoin",
    Callback  = function()
        while wait(1) do
    game:GetService("TeleportService"):Teleport(game.PlaceId, game:GetService("Players").LocalPlayer)
    end
end})

local Button = Other:CreateButton({
    Name = "Server Hop",
    Callback  = function()
        	    while wait(1) do
	        function ListServers(cursor) local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or "")) return Http:JSONDecode(Raw) end local Server, Next; repeat local Servers = ListServers(Next) Server = Servers.data[6] Next = Servers.nextPageCursor until Server TPS:TeleportToPlaceInstance(_place,Server.id,game.Players.LocalPlayer)
    end
end})

local Button = Other:CreateButton({
    Name = "Join Classic",
    Callback  = function()
        while wait(1) do
    game:GetService("TeleportService"):Teleport(379614936, game:GetService("Players").LocalPlayer)
    end
end})

local Button = Other:CreateButton({
    Name = "Join Pro",
    Callback  = function()
        while wait(1) do
    game:GetService("TeleportService"):Teleport(860428890, game:GetService("Players").LocalPlayer)
    end
end})

local Button = Other:CreateButton({
    Name = "Join Freeplay",
    Callback  = function()
          while wait(1) do
    game:GetService("TeleportService"):Teleport(5006801542, game:GetService("Players").LocalPlayer)
    end
end})

local Button = Other:CreateButton({
    Name = "Join Comp",
    Callback  = function()
        	    while wait(1) do
    game:GetService("TeleportService"):Teleport(866472074, game:GetService("Players").LocalPlayer)
    end
end})


local Section = hi:CreateSection("UI Settings")
local Button = hi:CreateButton({
   Name = "Destroy UI",
   Callback = function()
       Rayfield:Destroy()
   end,
})

local Button = hi:CreateButton({
   Name = "Save Configs",
   Callback = function()
       game.StarterGui:SetCore("SendNotification", {

        Title = "Saving Configs";

        Text = "To save your configs simply change _G.ConfigSaving = false to _G.ConfigSaving = true and all of your configs will be saved!";

        Duration = 20;


})
       game.StarterGui:SetCore("SendNotification", {

        Title = "Saving Configs";

        Text = "You will find this above your loadstring in your executor! If it isn't there simply copy the code in the notification above";

        Duration = 20;


})
   end,
})

game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        player.PlayerLeaving:Connect(function()
            game.Players:JoinPlayer(player)
        end)
    end)
end)



while getgenv().ServerHop == true do
    wait(5)
if getPlayers() <= 4 then
   function ListServers(cursor) local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or "")) return Http:JSONDecode(Raw) end local Server, Next; repeat local Servers = ListServers(Next) Server = Servers.data[6] Next = Servers.nextPageCursor until Server TPS:TeleportToPlaceInstance(_place,Server.id,game.Players.LocalPlayer)
end
end

task.spawn(function()
    game:GetService("RunService").Stepped:connect(function()
        if getgenv().rj == true then
            getgenv().rejoin = game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
    if child.Name == 'ErrorPrompt' and child:FindFirstChild('MessageArea') and child.MessageArea:FindFirstChild("ErrorFrame") then
        game:GetService("TeleportService"):Teleport(game.PlaceId)
    end
        end)
    end
end)
end)

while wait(1) do
        if getgenv().Advertise == true then
local r = game.ReplicatedStorage.Remotes.nugget;
wait(10)
r:FireServer("Sub to Radeon Assassin Scripts on YT for this script with TP AutoKill, HBE, silent aim and more for free!", "Global", Color3.fromRGB(100, 100, 255), "[VIP]")
wait(2)
r:FireServer("I also have bloxburg scripts, MM2 scripts, PET SIM X scripts and more!", "Global", Color3.fromRGB(100, 100, 255), "[VIP]") 
wait(2)
r:FireServer("Want your clan to get 1st on lb? Add me Radeon 2SOl and I will grind 6 bots for your clan!", "Global", Color3.fromRGB(100, 100, 255), "[VIP]") 
wait(5)
r:FireServer("I am currently doing a TOP 100 GIVEAWAY on my YT Radeon Assassin Scripts! Winner gets a free astral prince!!!", "Global", Color3.fromRGB(100, 100, 255), "[VIP]") 
wait(5)
r:FireServer("Sub to Radeon Assassin Scripts on YT for scripting tutorials and how to use create your own hack!", "Global", Color3.fromRGB(100, 100, 255), "[VIP]")
end
end

Rayfield:LoadConfiguration()
